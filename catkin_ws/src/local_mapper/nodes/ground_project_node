#!/usr/bin/env python3

import cv2
import numpy as np
import numpy_extra as npe
import rospy
import threading

from ipm import IPM

from cv_bridge import *
from transformations import euler_from_quaternion, quaternion_from_euler
from sensor_msgs.msg import *
from std_msgs.msg import *
from nav_msgs.msg import *
from geometry_msgs.msg import *

class LocalMapper(object):
    def __init__(self,
      ns_camera = "/camera_front_t", ns_imu = "/imu", ns_vehicle = "/vehicle", pixels_per_meter = 8.0,
      configuration = "camera_ethernet_imx291"):
        rospy.init_node("local_mapper_node")

        self.pixels_per_meter = pixels_per_meter

        self.sub_image_raw = rospy.Subscriber(
            "%s/image_raw" % ns_camera, Image, self.on_image_raw)

        self.ground_plane_r, self.ground_plane_theta = None, None

        self.is_initialized = False

        self.local_map = np.zeros((1024, 1024, 3), dtype=np.uint8)

        self.map_center_x = 0.0
        self.map_center_y = 0.0

        self.cur_y = 0.0
        self.cur_x = -self.local_map.shape[0] / self.pixels_per_meter * 0.5
        self.cur_yaw = 0.0
        self.velocity_x = 0.0

        self.ipm = IPM(pixels_per_meter = self.pixels_per_meter, configuration = configuration)
        self.lock = threading.Lock()
        self.is_initialized = True

    def on_image_raw(self, msg):
        self.lock.acquire()
        img = imgmsg_to_cv2(msg)

        if self.ground_plane_r is None or self.ground_plane_theta is None:
            self.ground_plane_r, self.ground_plane_theta = self.ipm.get_ground_plane(img.shape)

        cutoff_top = int(img.shape[0] * 0.4)
        cutoff_bottom = int(img.shape[0] * 0.9)

        img = img[cutoff_top:cutoff_bottom,:]
        ground_plane_r = self.ground_plane_r[cutoff_top:cutoff_bottom,:]
        ground_plane_theta = self.ground_plane_theta[cutoff_top:cutoff_bottom,:]

        values_y = self.cur_y + ground_plane_r * np.sin(ground_plane_theta + self.cur_yaw)
        values_x = self.cur_x + ground_plane_r * np.cos(ground_plane_theta + self.cur_yaw)

        values_py = (values_y * self.pixels_per_meter + self.local_map.shape[0] / 2.0).astype(np.int16)
        values_px = (values_x * self.pixels_per_meter + self.local_map.shape[1] / 2.0).astype(np.int16)

        where_valid = (values_py >= 0) & (values_px >= 0) & \
            (values_py < self.local_map.shape[0]) & (values_px < self.local_map.shape[1])

        self.local_map *= 0

        values_py = values_py[where_valid]
        values_px = values_px[where_valid]
        img = img[where_valid]

        self.local_map *= 0

        self.local_map[values_py, values_px, :] = img

        self.lock.release()

        cv2.imshow('local_map', self.local_map[::-1,:])
        cv2.waitKey(1)

    def spin(self):
        rospy.spin()

if __name__ == "__main__":
    local_mapper = LocalMapper()
    local_mapper.spin()

