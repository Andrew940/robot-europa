#!/usr/bin/env python3

import cv2
import numpy as np
import rospy

from ipm import IPM

from cv_bridge import *
from transformations import euler_from_quaternion, quaternion_from_euler
from sensor_msgs.msg import *
from std_msgs.msg import *
from nav_msgs.msg import *
from geometry_msgs.msg import *

class LocalMapper(object):
    def __init__(self,
      ns_camera = "/camera_front", ns_imu = "/imu", ns_vehicle = "/vehicle", pixels_per_meter = 10.0,
      configuration = "camera_ethernet_imx291"):
        rospy.init_node("local_mapper_node")

        self.pixels_per_meter = pixels_per_meter

        self.sub_semantic = rospy.Subscriber(
            "%s/semantic" % ns_camera, Image, self.on_semantic)
        self.sub_imu_data = rospy.Subscriber(
            "%s/data" % ns_imu, Imu, self.on_imu_data)
        self.sub_speed = rospy.Subscriber(
            "%s/speed" % ns_vehicle, Float32, self.on_speed)

        while not rospy.has_param("%s/semantic_categories" % ns_camera):
            rospy.loginfo_throttle(10, "waiting for categories")
            rospy.sleep(1)

        self.categories = rospy.get_param("%s/semantic_categories" % ns_camera)
        self.color_map = np.array([list(reversed(c["color"])) for c in self.categories],
            dtype=np.uint8)
        self.local_map = np.zeros((1024, 1024, len(self.categories)))
        self.cur_y = 0.0 # 255.0 / self.pixels_per_meter
        self.cur_x = 0.0 # 255.0 / self.pixels_per_meter
        self.cur_yaw = 0.0

        self.ipm = IPM(pixels_per_meter = self.pixels_per_meter, configuration = configuration)
        self.ground_plane_r, self.ground_plane_theta = None, None

    def on_speed(self, msg):
        pass

    def on_imu_data(self, msg):
        pass

    def on_semantic(self, msg):
        print("on_semantic")
        logits = imgmsg_to_cv2(msg)
        if self.ground_plane_r is None or self.ground_plane_theta is None:
            self.ground_plane_r, self.ground_plane_theta = self.ipm.get_ground_plane(logits.shape)

        values_y = self.cur_y + self.ground_plane_r * np.sin(self.ground_plane_theta + self.cur_yaw)
        values_x = self.cur_x + self.ground_plane_r * np.cos(self.ground_plane_theta + self.cur_yaw)

        values_py = (values_y * self.pixels_per_meter + self.local_map.shape[0] / 2.0).astype(np.int16)
        values_px = (values_x * self.pixels_per_meter + self.local_map.shape[1] / 2.0).astype(np.int16)

        where_valid = (values_py >= 0) & (values_px >= 0) & \
            (values_py < self.local_map.shape[0]) & (values_px < self.local_map.shape[1])

        self.local_map *= 0

        values_py = values_py[where_valid]
        values_px = values_px[where_valid]
        logits = logits[where_valid]

        self.local_map *= 0

        np.add.at(self.local_map, \
            (values_py, values_px, logits),
            1
        )

#                np.add.at(self.local_map,
#            (offsets_y, offsets_x, semantic),
#            self.semantic.weights[semantic]
#        )

        self.local_map_flat = np.argmax(self.local_map, axis=2)
        cv2.imshow('local_map', self.color_map[self.local_map_flat[::-1,:]])
        #cv2.imshow('local_map', self.ground_plane_r / 30)
        cv2.waitKey(1)

    def publish(self):
        pass

    def spin(self):
        rospy.spin()

if __name__ == "__main__":
    local_mapper = LocalMapper()
    local_mapper.spin()

